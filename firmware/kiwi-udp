/*
 * MERGED FIRMWARE: RP2040 Connect + TB6612FNG + UDP Control
 * DEBUG VERSION: Prints incoming UDP packets to Serial Monitor
 */

#include <SPI.h>
#include <WiFiNINA.h> 
#include <WiFiUdp.h>
#include <Wire.h>
#include <Servo.h>
#include "I2Cdev.h"
#include "MPU6050.h"

// ---------------- WIFI SETTINGS ----------------
const char* ssid     = "OLIN-DEVICES";
const char* password = "BestOval4Engineers!";

// ---------------- UDP SETTINGS -----------------
WiFiUDP udp;
const unsigned int localUdpPort = 54322;  // must match ROS UDP_PORT
char packetBuffer[255]; // Buffer to hold incoming packet

const float ACCEL_SCALE_FACTOR = 16384.0;
const float GYRO_SCALE_FACTOR = 131.0;

unsigned long lastImuReadTime = 0;
const unsigned long IMU_READ_INTERVAL = 10; // 10ms = 100Hz

// ---------------- OBJECTS ----------------
Servo esc;
int fanPulse = 1000; 

// ---------------- MARKER SERVO ------------------------
Servo markerServo;
const int MARKER_UP_ANGLE = 0;   // Servo angle for marker up (False)
const int MARKER_DOWN_ANGLE = 160;  // Servo angle for marker down (True)

// ---------------- SAFETY STATE -----------------------
unsigned long lastCommandTime = 0;
const unsigned long COMMAND_TIMEOUT = 50; 
bool hasReceivedCommand = false;

// ---------------- DEBUG SETTINGS --------------------
#define DEBUG_MODE false  // Set to true to enable Serial prints (slows down processing)

// ---------------- HELPER: MOTOR SPEED SET -------------------
void setMotorSpeed(Adafruit_DCMotor *motor, float velocity) {
  if (velocity > 1.0) velocity = 1.0;
  if (velocity < -1.0) velocity = -1.0;

  int pwmVal = int(fabs(velocity) * 255);
  int pinPWM, pinDir1, pinDir2;

  if (motorID == 1) {
    pinPWM = M1_PWM; pinDir1 = M1_BIN1; pinDir2 = M1_BIN2;
  } else if (motorID == 2) {
    pinPWM = M2_PWMA; pinDir1 = M2_AIN1; pinDir2 = M2_AIN2;
  } else if (motorID == 3) {
    pinPWM = M3_PWM; pinDir1 = M3_BIN1; pinDir2 = M3_BIN2;
  } else {
    return; 
  }

  if (velocity > 0) {
    digitalWrite(pinDir1, HIGH); digitalWrite(pinDir2, LOW);
    analogWrite(pinPWM, pwmVal);
  } else if (velocity < 0) {
    digitalWrite(pinDir1, LOW); digitalWrite(pinDir2, HIGH);
    analogWrite(pinPWM, pwmVal);
  } else {
    digitalWrite(pinDir1, LOW); digitalWrite(pinDir2, LOW);
    analogWrite(pinPWM, 0);
  }
}

// ---------------- HELPER: FAN CONTROL ----------------
void setFanPulse(int pulse) {
  if (pulse < 1000) pulse = 1000;
  if (pulse > 2000) pulse = 2000;
  fanPulse = pulse;
  esc.writeMicroseconds(fanPulse);
}

// ---------------- HELPER: IMU SENDER ----------------
void readAndSendImu() {
  accelgyro.getMotion6(&ax, &ay, &az, &gx, &gy, &gz);

  float accelX_g = ax / ACCEL_SCALE_FACTOR;
  float accelY_g = ay / ACCEL_SCALE_FACTOR;
  float accelZ_g = az / ACCEL_SCALE_FACTOR;
  float gyroX_dps = gx / GYRO_SCALE_FACTOR;
  float gyroY_dps = gy / GYRO_SCALE_FACTOR;
  float gyroZ_dps = gz / GYRO_SCALE_FACTOR;

  if (hasValidSender) {
    char imuBuffer[100];
    snprintf(imuBuffer, sizeof(imuBuffer), "IMU %.3f %.3f %.3f %.3f %.3f %.3f",
             accelX_g, accelY_g, accelZ_g, gyroX_dps, gyroY_dps, gyroZ_dps);
    
    udp.beginPacket(lastSenderIP, lastSenderPort);
    udp.write((uint8_t*)imuBuffer, strlen(imuBuffer));
    udp.endPacket();
  }
}

// ---------------- HELPER: MARKER SET ----------------
void setMarkerAngle(int angleDeg) {
  if (angleDeg < 0) angleDeg = 0;
  if (angleDeg > 180) angleDeg = 180;
  markerServo.write(angleDeg);
  #if DEBUG_MODE
    Serial.print("Marker angle set to: ");
    Serial.println(angleDeg);
  #endif
}

// ===================== SETUP ========================
void setup() {
  Serial.begin(115200);
  
  pinMode(M1_BIN1, OUTPUT); pinMode(M1_BIN2, OUTPUT); pinMode(M1_PWM, OUTPUT);
  pinMode(M2_AIN1, OUTPUT); pinMode(M2_AIN2, OUTPUT); pinMode(M2_PWMA, OUTPUT);
  pinMode(M3_BIN1, OUTPUT); pinMode(M3_BIN2, OUTPUT); pinMode(M3_PWM, OUTPUT);

  esc.attach(ESC_PIN);
  esc.writeMicroseconds(1000); 
  
  Wire.begin();
  Serial.println("Initializing MPU-6050...");
  accelgyro.initialize();
  if (accelgyro.testConnection()) {
    Serial.println("MPU-6050 connection successful!");
  } else {
    Serial.println("MPU-6050 connection failed! Check wiring.");
  }

  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println("Communication with WiFi module failed!");
    while (true);
  }

  // 3. Setup Marker Servo
  markerServo.attach(8);
  setMarkerAngle(MARKER_UP_ANGLE);  // Start with marker up

  // 4. Connect to Wi-Fi
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nConnected!");
  Serial.print("IP Address: ");
  Serial.println(WiFi.localIP());

  // 5. Start UDP
  udp.begin(localUdpPort);
  Serial.print("Listening on UDP port: ");
  Serial.println(localUdpPort);

  delay(3000); 
  Serial.println("System Ready.");
}

// ====================== LOOP ========================
void loop() {
  int packetSize = udp.parsePacket();
  if (packetSize > 0) {
    // Discard queued packets; keep only the latest
    while (udp.parsePacket() > 0) {
      udp.read(packetBuffer, 255);
    }

    int len = udp.read(packetBuffer, 255);
    if (len > 0) packetBuffer[len] = 0;

    if (strncmp(packetBuffer, "CMD", 3) == 0) {
      float v1 = 0.0, v2 = 0.0, v3 = 0.0;
      bool parseSuccess = false;

      char bufferCopy[255];
      strncpy(bufferCopy, packetBuffer, sizeof(bufferCopy));
      bufferCopy[sizeof(bufferCopy) - 1] = 0;

      char *token = strtok(bufferCopy, " ");
      if (token && strcmp(token, "CMD") == 0) {
        token = strtok(NULL, " ");
        if (token) {
          v1 = atof(token);
          token = strtok(NULL, " ");
          if (token) {
            v2 = atof(token);
            token = strtok(NULL, " \n\r");
            if (token) {
              v3 = atof(token);
              parseSuccess = true;
            }
          }
        }
      }

      if (parseSuccess) {
        lastCommandTime = millis();
        hasReceivedCommand = true;
        setMotorSpeed(wheel1, v1);
        setMotorSpeed(wheel2, v2);
        setMotorSpeed(wheel3, v3);
      }
    }
    // FAN: "FAN pulse"
    else if (strncmp(packetBuffer, "FAN", 3) == 0) {
      int fanVal = fanPulse;
      bool parseSuccess = false;

      char bufferCopy[255];
      strncpy(bufferCopy, packetBuffer, sizeof(bufferCopy));
      bufferCopy[sizeof(bufferCopy) - 1] = 0;

      char *token = strtok(bufferCopy, " ");
      if (token && strcmp(token, "FAN") == 0) {
        token = strtok(NULL, " \n\r");
        if (token) {
          fanVal = atoi(token);
          parseSuccess = true;
        }
      }

      if (parseSuccess) {
        setFanPulse(fanVal);
      }
    }
    else if (strncmp(packetBuffer, "MARKER_ANGLE", 12) == 0) {
      // MARKER_ANGLE command expects: "MARKER_ANGLE <deg>"
      int angleVal = MARKER_UP_ANGLE; // default to up if parse fails
      bool parseSuccess = false;

      char bufferCopy[255];
      strncpy(bufferCopy, packetBuffer, sizeof(bufferCopy));
      bufferCopy[sizeof(bufferCopy) - 1] = 0;

      char *token = strtok(bufferCopy, " ");
      if (token && strcmp(token, "MARKER_ANGLE") == 0) {
        token = strtok(NULL, " \n\r");
        if (token) {
          angleVal = atoi(token);
          parseSuccess = true;
        }
      }

      if (parseSuccess) {
        setMarkerAngle(angleVal);
      }
    }
    else if (strncmp(packetBuffer, "MARKER", 6) == 0) {
      // MARKER command expects: "MARKER <0|1>" where 1 = down (True), 0 = up (False)
      int markerVal = 0;
      bool parseSuccess = false;

      char bufferCopy[255];
      strncpy(bufferCopy, packetBuffer, sizeof(bufferCopy));
      bufferCopy[sizeof(bufferCopy) - 1] = 0;

      char *token = strtok(bufferCopy, " ");
      if (token && strcmp(token, "MARKER") == 0) {
        token = strtok(NULL, " \n\r");
        if (token) {
          markerVal = atoi(token);
          parseSuccess = true;
        }
      }

      if (parseSuccess) {
        if (markerVal == 1) {
          setMarkerAngle(MARKER_DOWN_ANGLE);
        } else {
          setMarkerAngle(MARKER_UP_ANGLE);
        }
      }
    }
  }

  // 2. SAFETY TIMEOUT
  if (hasReceivedCommand && (millis() - lastCommandTime > COMMAND_TIMEOUT)) {
    setMotorSpeed(1, 0);
    setMotorSpeed(2, 0);
    setMotorSpeed(3, 0);
    hasReceivedCommand = false; 
    // Serial.println("Timeout: Stopping Motors"); // Uncomment if you want to see timeout events
  }

  // 3. IMU TELEMETRY
  if (millis() - lastImuReadTime >= IMU_READ_INTERVAL) {
    readAndSendImu();
    lastImuReadTime = millis();
  }
}